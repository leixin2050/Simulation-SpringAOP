# Simulation-SpringAOP
&emsp;&emsp;SpringAOP 的底层原理也是使用代理机制实现方法的代理实现，以及通过给切面的切点添加拦截器，在我自己模拟实现的AOP中，
基本上实现了Spring的所有功能。<br>
&emsp;&emsp;基本上分为两个三个部分：<br>
    &emsp;&emsp;1、代理对象的获取 <br>
        &emsp;&emsp;对于代理对象的获取，我采用了两种实现方式，必须基于接口的JDKProxy和不需要接口，使用子类的CGLib代理机制。
    将二者整合为一个LWProxy，提供给用户选择使用何种代理机制来实现代理。<br>
    &emsp;&emsp;2、切点的加入以及拦截器链的实现<br>
        &emsp;&emsp;由于想获取到切点就必须提供方法的全类名以及参数的全类名，对于使用者来说是极大的不便，于是我采用了正则表达式的处理方式，
    用户只需要提供一个普通的类名、或方法名及参数，对于其他的地方使用'*'来代替，在我的MethodInvoker类中提供了处理用户提交的普通
    的类名与参数名的toRegex方法，此方法把简单的字符串转换为正则表达式，从而找到符合的切面的切点。<br>
        &emsp;&emsp;而对于拦截器链的实现，采取了循环递归的方式添加拦截器链,且使用了不同的实现方法使得前置拦截的执行顺序为添加的顺序，而后置
    拦截的顺序为添加的顺序的倒序，类似于SpringMVC中对于拦截器的处理。<br>
    &emsp;&emsp;3、对代理对象执行方法的参数以及结果的获取与处理
        &emsp;&emsp;对于代理实现的方法的参数与结果采用一个单例且线程安全的MethodArgAndResult.java来存储，这样处理的好处在于，我们可以实现
    在自定义的拦截器中轻松获取到执行方法参数与返回值。
